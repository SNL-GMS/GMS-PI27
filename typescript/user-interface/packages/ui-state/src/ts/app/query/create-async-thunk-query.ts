import type { WithRequired } from '@gms/common-model/lib/type-util/type-util';
import type { Logger } from '@gms/common-util';
import {
  epochSecondsNow,
  MILLISECONDS_IN_MINUTE,
  MILLISECONDS_IN_SECOND,
  sleep
} from '@gms/common-util';
import { UILogger } from '@gms/ui-util';
import type { ExtraOptions, PriorityRequestConfig } from '@gms/ui-workers';
import { axiosBaseQuery } from '@gms/ui-workers';
import type { ActionReducerMapBuilder, AsyncThunk, Draft, PayloadAction } from '@reduxjs/toolkit';
import { createAsyncThunk } from '@reduxjs/toolkit';
import type { BaseQueryApi } from '@reduxjs/toolkit/dist/query';
import flatMap from 'lodash/flatMap';
import isEqual from 'lodash/isEqual';
import sortBy from 'lodash/sortBy';
import PQueue from 'p-queue';
import React from 'react';
import { useSelector } from 'react-redux';

import type { AppDispatch, AppState } from '../store';
import {
  addAsyncFetchHistoryEntryFulfilled,
  addAsyncFetchHistoryEntryPending,
  addAsyncFetchHistoryEntryRejected,
  flattenFilterHistory,
  flattenHistory
} from './async-fetch-util';
import type { AsyncFetchHistory, AsyncFetchHistoryEntry } from './types';
import { AsyncActionStatus, CANCELED } from './types';
import { appendPreCacheConfigToRequestConfig } from './util';

/**
 * A function type that generates a unique id for the provided {@link Args}
 *
 * Generates a unique string identifier generated from the arguments.
 *
 * @param arg the query arguments
 * @returns a unique string identifier generated from the arguments
 */
export type IdGenerator<Args> = (args: Args) => string;

/**
 * A function type that returns a Redux slice of type {@link SliceState} from the store {@link State}.
 *
 * Getter to select the slice {@link SliceState} from the store ({@link State}).
 *
 * @example
 * ```ts
 * getSliceState: state => state.data
 * ```
 *
 * @param state the redux state store
 * @returns the selected slice from the redux state store
 */
export type GetSliceState<State, SliceState> = (state: State) => SliceState;

/**
 * A function type that returns history from the state {@link SliceState}.
 *
 * Getter to select the history {@link AsyncFetchHistory}<{@link Args}> from the {@link SliceState}.
 *
 * @example
 * ```ts
 * getHistory: state => state.history
 * ```
 *
 * @param state a slice from the redux state store
 * @returns the selected history from the slice
 */
export type GetHistory<Args, SliceState> = (state: SliceState) => AsyncFetchHistory<Args>;

/**
 * A function type that returns writable history ({@link Draft}) from the state {@link SliceState}.
 */
type GetWritableHistory<Args, SliceState> = (
  state: Draft<SliceState>
) => Draft<AsyncFetchHistory<Args>>;

/**
 * A function type that returns a boolean indicating if the query should be skipped based on the {@link Args}.
 *
 * Validates the query arguments and returns true
 * if the query should be skipped; false otherwise.
 *
 * @param args the query arguments
 * @returns true if the query should be skipped; false otherwise
 */
export type ShouldSkip<Args> = (args: Args) => boolean;

/**
 * A function type that transforms or performs deduplication of the {@link Args}.
 *
 * (optional) Performs any necessary transformation of the arguments and any deduplication.
 *
 * @param args the query arguments
 * @param history the fully query {@link AsyncFetchHistory}<{@link Args}> history
 * @param id the unique identifier generated by {@link idGenerator}
 * @param entries the flatten collection of {@link AsyncFetchHistoryEntry}<{@link Args}>[] entries from the history.
 * This collection is pre-filtered excluding the entry for the current request id and any requests in
 * which the status {@link AsyncActionStatus} was rejected.
 * @returns returns the transformed and/or deduplicated arguments
 */
export type TransformArgs<Args> = (
  args: Args,
  history: AsyncFetchHistory<Args>,
  id: string,
  entries: AsyncFetchHistoryEntry<Args>[]
) => Args;

/**
 * A function type that prepares the request config(s). Typically used to chunk up a single request into multiple.
 *
 * (optional) Prepares (sets the data field) the request config for the query.
 * This function is expected to return 1 or more request config objects. Returning
 * multiple request config objects can be used to `chunk` a request. The query
 * function will be called for every request config returned.
 *
 * @param args the query arguments
 * @param requestConfig the base request config
 * @param history the fully query {@link AsyncFetchHistory}<{@link Args}> history
 * @param id the unique identifier generated by {@link idGenerator}
 * @param entries the flatten collection of {@link AsyncFetchHistoryEntry}<{@link Args}>[] entries from the history.
 * This collection is pre-filtered excluding the entry for the current request id and any requests in
 * which the status {@link AsyncActionStatus} was rejected.
 * @param state the redux state store
 * @returns a collection of complete request configs
 */
export type PrepareRequestConfig<Args, State> = (
  args: Args,
  requestConfig: PriorityRequestConfig<unknown>,
  history: AsyncFetchHistory<Args>,
  id: string,
  entries: AsyncFetchHistoryEntry<Args>[],
  state: State
) => WithRequired<PriorityRequestConfig<Args>, 'data'>[];

/**
 * A function type that provides a custom query function with optional custom parameters.
 *
 * (optional) Custom query function. This function would replace the normal axios call
 * using the {@link axiosBaseQuery}, e.g. this could be an asynchronous call to a webworker.
 *
 * @param requestConfig the request config
 * @returns a Promise of the {@link Result} type
 */
export type QueryFunc<Args, CustomQueryParams extends [...unknown[]], Result> = (
  requestConfig: WithRequired<PriorityRequestConfig<Args>, 'data'>,
  ...additionalParameters: CustomQueryParams
) => Promise<Result | undefined>;

/**
 * A function type that combines multiple results.
 *
 * (optional) Preforms any necessary transformation of the result and
 * Performs any necessary transformation of the results and
 * combines the results received from the query
 *
 * !required if {@link prepareRequestConfig} returns multiple request configs
 * !required if pre-cached results exist returns multiple request configs
 *
 * @param args the query arguments
 * @param results the results received from the query; typically this will be a single
 * result unless {@link prepareRequestConfig} provided multiple request configs (chunked the query); or
 * if there are pre-cached results
 * @returns returns the transformed result
 */
export type TransformResult<Args, Result> = (
  args: Args,
  results: (Result | undefined)[]
) => Result | undefined;

/**
 * A function type used to validate the query results.
 *
 * (optional) Performs any validation of the results.
 *
 * @param args the query arguments
 * @param result the query result
 * @param state the redux state store
 * @returns the query result
 */
export type ValidateResult<Args, Result, State> = (
  args: Args,
  result: Result | undefined,
  state: State
) => ValidationErrors | undefined;

/**
 * A function type that is used to update the Redux {@link SliceState} with the {@link Result}.
 *
 * Updates the Redux state slice {@link SliceState}.
 * This operation is called when the redux async thunk action is `fulfilled` and
 * should be used to update the {@link SliceState} with the {@link Result}.
 *
 * @param payload the payload form the action
 * @param state a slice from the redux state store
 */
export type UpdateState<Args, Result, SliceState> = (
  action: PayloadAction<
    Result | undefined,
    string,
    {
      arg: Args;
      requestId: string;
      requestStatus: 'fulfilled';
    },
    never
  >,
  state: Draft<SliceState>
) => void;

/**
 * A function type that is used to pre-cache query results.
 */
type PreCache<Args> = (
  args: Args,
  getPreCacheVisibility: (requestConfig: PriorityRequestConfig<Args>) => number
) => Promise<void>;

/**
 * Represents a rejected value
 */
export interface ValidationErrors {
  errorMessage: string;
  errors?: Record<string, string>;
}

/**
 * The {@link CreateAsyncThunkQuery} props or options.
 */
export interface CreateAsyncThunkQueryProps<
  Args,
  Result,
  SliceState,
  CustomQueryParams extends [...unknown[]] = never,
  State = AppState
> {
  /**
   * The unique identifier for the redux action
   */
  typePrefix: string;

  /**
   * The request configuration
   * !excludes the data; will be overridden
   */
  config: PriorityRequestConfig<unknown>;

  /**
   * (optional) an logger instance
   */
  logger?: Logger;

  /**
   * The maximum number of active async requests (calls to the query function) that can be issued at a single time.
   * This is dependent on the the number of request configurations returned by {@link prepareRequestConfig}.
   *
   * For example, if ${@link maxActiveAsyncRequests} is set to 10 and {@link prepareRequestConfig} returns 30
   * request configs (means chunked into 30 separate requests); all 30 requests will not be issued at the same time,
   * the maximum number of active requests is 10.
   *
   * @default 100
   */
  maxActiveAsyncRequests?: number;

  /**
   * Generates a unique string identifier generated from the arguments.
   *
   * @param arg the query arguments
   * @returns a unique string identifier generated from the arguments
   */
  idGenerator: IdGenerator<Args>;

  /**
   * Getter to select the slice {@link SliceState} from the store ({@link State}).
   *
   * @example
   * ```ts
   * getSliceState: state => state.data
   * ```
   *
   * @param state the redux state store
   * @returns the selected slice from the redux state store
   */
  getSliceState: GetSliceState<State, SliceState>;

  /**
   * Getter to select the history {@link AsyncFetchHistory}<{@link Args}> from the {@link SliceState}.
   *
   * @example
   * ```ts
   * getHistory: state => state.history
   * ```
   *
   * @param state a slice from the redux state store
   * @returns the selected history from the slice
   */
  getHistory: GetHistory<Args, SliceState>;

  /**
   * Validates the query arguments and returns true
   * if the query should be skipped; false otherwise.
   *
   * @param args the query arguments
   * @returns true if the query should be skipped; false otherwise
   */
  shouldSkip: ShouldSkip<Args>;

  /**
   * (optional) Performs any necessary transformation of the arguments and any deduplication.
   *
   * @param args the query arguments
   * @param entries the flatten collection of {@link AsyncFetchHistoryEntry}<{@link Args}>[] entries from the history.
   * This collection is pre-filtered excluding the entry for the current request id and any requests in
   * which the status {@link AsyncActionStatus} was rejected.
   * @param history the fully query {@link AsyncFetchHistory}<{@link Args}> history
   * @param id the unique identifier generated by {@link idGenerator}
   * @returns returns the transformed and/or deduplicated arguments
   */
  transformArgs?: TransformArgs<Args>;

  /**
   * (optional) Prepares (sets the data field) the request config for the query.
   * This function is expected to return 1 or more request config objects. Returning
   * multiple request config objects can be used to `chunk` a request. The query
   * function will be called for every request config returned.
   *
   * @param args the query arguments
   * @param requestConfig the base request config
   * @param history the fully query {@link AsyncFetchHistory}<{@link Args}> history
   * @param id the unique identifier generated by {@link idGenerator}
   * @param entries the flatten collection of {@link AsyncFetchHistoryEntry}<{@link Args}>[] entries from the history.
   * This collection is pre-filtered excluding the entry for the current request id and any requests in
   * which the status {@link AsyncActionStatus} was rejected.
   * @param state the redux state store
   * @returns a collection of complete request configs
   */
  prepareRequestConfig?: PrepareRequestConfig<Args, State>;

  /**
   * (optional) Custom query function parameter builder.
   * This function builds and provides additional parameters to a custom query function based on state.
   *
   * @param state the state provided by the {@link getState}
   * @returns an collection of objects that will be passed into the custom query function {@link customQueryFunc}
   */
  customQueryParams?: (state: State) => CustomQueryParams;

  /**
   * (optional) Custom query function. This function would replace the normal axios call
   * using the {@link axiosBaseQuery}, e.g. this could be an asynchronous call to a webworker.
   *
   * @param requestConfig the request config
   * @returns a Promise of the {@link Result} type
   */
  customQueryFunc?: QueryFunc<Args, CustomQueryParams, Result>;

  /**
   * Performs any necessary transformation of the results and
   * combines the results received from the query
   *
   * @param args the query arguments
   * @param results the results received from the query; this might include multiple
   * results where a query was chunked or pre-cache chunks exists
   * @returns returns the transformed result
   */

  /**
   * (optional) Preforms any necessary transformation of the result and
   * Performs any necessary transformation of the results and
   * combines the results received from the query
   *
   * !required if {@link prepareRequestConfig} returns multiple request configs
   * !required if pre-cached results exist returns multiple request configs
   *
   * @param args the query arguments
   * @param results the results received from the query; typically this will be a single
   * result unless {@link prepareRequestConfig} provided multiple request configs (chunked the query); or
   * if there are pre-cached results
   * @returns returns the transformed result
   */
  transformResult?: TransformResult<Args, Result>;

  /**
   * (optional) Performs any validation of the results.
   *
   * @param args the query arguments
   * @param result the query result
   * @param state the redux state store
   * @returns the query result
   */
  validateResult?: ValidateResult<Args, Result, State>;

  /**
   * Updates the Redux state store slice {@link SliceState}.
   * This operation is called when the redux async thunk action is `fulfilled` and
   * should be used to update the {@link SliceState} with the {@link Result}.
   *
   * @param payload the payload form the action
   * @param state a slice from the redux state store
   */
  updateState: UpdateState<Args, Result, SliceState>;

  /**
   * (optional) A boolean flag to indicate whether or not pre-caching is enabled or not
   *
   * @default false
   */
  preCacheEnabled?: boolean;
}

/**
 * The return type of {@link createAsyncThunkQuery}.
 */
export interface CreateAsyncThunkQuery<Args, Result, State, SliceState> {
  /**
   * The asynchronous query thunk.
   * See {@link createAsyncThunk} and {@link AsyncThunk}
   */
  asyncQuery: AsyncThunk<
    Result | undefined,
    Args,
    {
      state: State;
      dispatch: AppDispatch;
      rejectValue: ValidationErrors;
      extra: unknown;
      serializedErrorType?: unknown;
      pendingMeta?: unknown;
      fulfilledMeta?: unknown;
      rejectedMeta?: unknown;
    }
  >;

  /**
   * A builder function for adding the asynchronous thunk actions to a reducer.
   *
   * !matchers must be added to the reducer after all case reducers
   *
   * @param builder A builder for an action <-> reducer map.
   * @returns returns a builder function for adding the asynchronous thunk actions to a reducer
   */
  addMatchReducers: (builder: ActionReducerMapBuilder<SliceState>) => void;

  /**
   * A {@link React} hook that provides an asynchronous method for requesting
   * to pre-cache a asynchronous thunk query.
   *
   * ! DOES NOT UPDATE REDUX STATE
   *
   * @param args the query arguments
   * @param getPreCachePriority (optional) a function that returns an optional pre-cache priority value
   * @returns an asynchronous method for requesting to pre-cache a asynchronous thunk query
   */
  usePreCache: () => PreCache<Args>;
}

/**
 * A throttle request configuration.
 * Defines the {@link attempts} and {@link throttleMs}.
 */
interface ThrottleRequest {
  /** the number of attempts apply this throttle time too; applies to any attempt less than and equal */
  attempts: number;
  /** the number or milliseconds that should be used to throttle  */
  throttleMs?: number;
}

/**
 * If {@link GMS_DISABLE_PRE_CACHE} is true then pre-cache is disabled; false otherwise;.
 *
 * {@link process.env.GMS_DISABLE_PRE_CACHE} is a global environment variable that can be used to disable all pre-cache.
 */
export const GMS_DISABLE_PRE_CACHE = process.env.GMS_DISABLE_PRE_CACHE === 'true';

/**
 * The default maximum number of active async requests that can be active at a time.
 */
const DEFAULT_MAX_ACTIVE_ASYNC_REQUESTS = 100;

/** The default logger for the async thunk query */
const DEFAULT_LOGGER = UILogger.create('GMS_ASYNC_QUERY', process.env.GMS_ASYNC_QUERY);

/**
 * Async Thunk Query Throttle Request Configuration
 */
export const AsyncThunkQueryThrottledRequestConfig: Readonly<ThrottleRequest[]> = Object.freeze(
  sortBy(
    [
      // no throttle time for the very first attempt; just execute
      { attempts: 1, throttleMs: 0 },
      // retry every 30 seconds for the attempts 2 - 6 attempts
      { attempts: 6, throttleMs: MILLISECONDS_IN_MINUTE / 2 },
      // retry every 1 minute for the attempts 7 - 11 attempts
      { attempts: 11, throttleMs: MILLISECONDS_IN_MINUTE },
      // retry 3 minutes for the attempts 12 - 16 attempts
      { attempts: 16, throttleMs: MILLISECONDS_IN_MINUTE * 3 },
      // retry every 5 minutes for the attempts 17 - 24 attempts
      { attempts: 24, throttleMs: MILLISECONDS_IN_MINUTE * 5 },
      // stop; no more attempts after the 25 attempts
      { attempts: 25 }
    ],
    e => e.attempts,
    e => e.throttleMs
  )
);

/**
 * Returns the throttle request time for the provided number of attempts.
 *
 * @param attempts the number of attempts to retrieve the throttle time
 * @returns the number of milliseconds to throttle the request; undefined means no throttle
 */
export function getThrottleRequestTimeMs(attempts: number): number | undefined {
  const configs = sortBy(
    AsyncThunkQueryThrottledRequestConfig,
    entry => entry.attempts,
    entry => entry.throttleMs
  );
  const config = configs.find(entry => attempts <= entry.attempts);
  return config?.throttleMs;
}

/**
 * Returns a {@link PriorityRequestConfig} with the provided data.
 *
 * @param args the query arguments
 * @param requestConfig the base request config
 * @returns a prepared request config with the data
 */
function defaultPrepareRequestConfig<Args>(
  args: Args,
  requestConfig: PriorityRequestConfig<unknown>
): WithRequired<PriorityRequestConfig<Args>, 'data'> {
  return { ...requestConfig, data: args };
}

/**
 * Helper function to return an async thunk query
 *
 * @param props the props {@link CreateAsyncThunkQueryProps} used to configure and setup an async thunk query
 * @param queuedRequests a record of queued requests
 * @param preCacheHistory a record of pre-cache history
 * @returns a async thunk
 */
function createAsyncQuery<
  Args,
  Result,
  SliceState,
  CustomQueryParams extends [...unknown[]],
  State
>(
  props: Required<CreateAsyncThunkQueryProps<Args, Result, SliceState, CustomQueryParams, State>>,
  queuedRequests: Record<string, number> = {},
  preCacheHistory: AsyncFetchHistory<Args> = {}
) {
  const { typePrefix, preCacheEnabled, logger, config, maxActiveAsyncRequests } = props;
  const { idGenerator, shouldSkip, getSliceState, getHistory, transformArgs } = props;
  const { prepareRequestConfig, customQueryParams, customQueryFunc } = props;
  const { transformResult, validateResult } = props;

  return createAsyncThunk<
    Result | undefined,
    Args,
    { state: State; dispatch: AppDispatch; rejectValue: ValidationErrors; extra: never }
  >(
    typePrefix,
    async (args: Args, { getState, fulfillWithValue, rejectWithValue, requestId }) => {
      try {
        if (queuedRequests[requestId] != null) {
          if (queuedRequests[requestId] > 0) {
            logger.debug(
              `Throttling request; waiting  ${queuedRequests[requestId]} milliseconds`,
              args
            );

            // throttle the request
            await sleep(queuedRequests[requestId]);
          }
        }

        const state = getState();
        let history = getHistory(getSliceState(state));
        let entries = flattenFilterHistory(history, requestId);

        let data = transformArgs(args, history, requestId, entries);

        if (shouldSkip(data)) {
          // no additional data needs to be fetched; return as fulfilled
          logger.debug(`No additional data needed; already retrieved for ${typePrefix}`, data);
          return fulfillWithValue(undefined);
        }

        logger.debug(`fetch: `, typePrefix, args, data);

        // determine if any of the pre-cache history overlaps
        const matchedPreCacheHistory: Record<string, AsyncFetchHistoryEntry<Args>> = {};
        if (preCacheEnabled) {
          Object.entries(
            flattenHistory(
              preCacheHistory,
              entry =>
                entry.request.status === AsyncActionStatus.fulfilled &&
                !isEqual(
                  transformArgs(data, { preCache: { preCache: entry.request } }, requestId, [
                    entry.request
                  ]),
                  data
                )
            )
          ).forEach(([key, value]) => {
            matchedPreCacheHistory[key] = value;
          });

          // combine the history and pre-cache history
          history = { ...history, preCache: matchedPreCacheHistory };
          entries = flattenFilterHistory(history, requestId);
          // update the data (transform) with the updated history
          data = transformArgs(data, history, requestId, entries);
        }

        // combine requests configs from {@link prepareRequestConfig} and any pre-cache requests
        const requestConfigs = [
          ...prepareRequestConfig(data, config, history, requestId, entries, state),
          ...flatMap(
            Object.entries(matchedPreCacheHistory).map(([, entry]) =>
              defaultPrepareRequestConfig(entry.arg, config)
            )
          )
        ];

        const requestQueue: PQueue = new PQueue({ concurrency: maxActiveAsyncRequests });

        const results = await requestQueue.addAll(
          requestConfigs.map(requestConfig => async () => {
            if (customQueryParams) {
              return customQueryFunc(requestConfig, ...customQueryParams(state));
            }
            return customQueryFunc(requestConfig, ...([] as unknown as CustomQueryParams));
          })
        );

        const result = transformResult(data, results);

        const validate = validateResult(data, result, state);
        if (validate !== undefined) {
          logger.error(`Failed ${typePrefix} (rejected) from validation`, validate);
          return rejectWithValue(validate);
        }

        return fulfillWithValue(result);
      } catch (error) {
        if (error.message !== CANCELED) {
          logger.error(`Failed ${typePrefix} (rejected)`, error, args);
        }
        return rejectWithValue(error);
      }
    },
    {
      idGenerator,
      condition: (args: Args, { getState }) => {
        const state = getState();
        const id = idGenerator(args);
        const history = getHistory(getSliceState(state));
        const entries = flattenFilterHistory(history, id);

        if (history?.[id]?.[id]) {
          const { status } = history[id][id];

          // if the request is already pending; do not execute
          if (status === AsyncActionStatus.pending) {
            return false;
          }

          // if the request was already fulfilled; do not execute
          if (status === AsyncActionStatus.fulfilled) {
            return false;
          }

          // if the request was already queued; do not execute
          if (queuedRequests[id] != null) {
            return false;
          }

          // if the request was already satisfied by other requests; do not execute
          if (shouldSkip(transformArgs(args, history, id, entries))) {
            return false;
          }

          // the request was previously rejected, then throttle the request if attempts remaining are remaining
          const throttleRequestMs = getThrottleRequestTimeMs(history[id][id].attempts + 1 || 0);
          if (throttleRequestMs != null) {
            const lastAttempt = history[id][id].time || 0;
            const sinceLastAttemptMs = (epochSecondsNow() - lastAttempt) * MILLISECONDS_IN_SECOND;
            const timeToThrottle = Math.round(throttleRequestMs - sinceLastAttemptMs);
            queuedRequests[id] = timeToThrottle;
            return true;
          }
          // all retry attempts have been exhausted
          return false;
        }

        // determine if the query should be skipped based on the provided args
        return !shouldSkip(args) && !shouldSkip(transformArgs(args, history, id, entries));
      }
    }
  );
}

/**
 * Pre-caches the provided request config
 *
 * @param id the unique pre-cache identifier
 * @param requestConfig the request config
 * @param preCacheHistory the pre-cache history
 * @param idGenerator unique id generator
 * @param getPreCacheVisibility function to get the pre-cache ordering
 * @param logger a logger
 */
async function preCache<Args, Result>(
  id: string,
  requestConfig: WithRequired<PriorityRequestConfig<Args>, 'data'>,
  preCacheHistory: AsyncFetchHistory<Args>,
  idGenerator: IdGenerator<Args>,
  getPreCacheVisibility: (requestConfig: PriorityRequestConfig<Args>) => number | undefined,
  logger: Logger
) {
  addAsyncFetchHistoryEntryPending(preCacheHistory, id, {
    meta: {
      arg: requestConfig.data,
      requestId: idGenerator(requestConfig.data),
      requestStatus: 'pending'
    },
    payload: undefined,
    type: 'preCache'
  });

  try {
    const preCacheRequestConfig = appendPreCacheConfigToRequestConfig(
      requestConfig,
      getPreCacheVisibility(requestConfig)
    );

    if (preCacheRequestConfig.baseURL == null) {
      logger.error(`Invalid pre-cache request config, url is provided`, preCacheRequestConfig);
      throw new Error(`Invalid pre-cache request config, url is provided`);
    }

    const axiosQueryFn = axiosBaseQuery<Result>({
      baseUrl: preCacheRequestConfig.baseURL
    });

    await axiosQueryFn(
      { requestConfig: preCacheRequestConfig },
      {} as BaseQueryApi,
      {} as ExtraOptions
    );
  } catch (error) {
    logger.debug(`Failed to pre-cache for`, requestConfig, error);
    addAsyncFetchHistoryEntryRejected(preCacheHistory, id, {
      meta: {
        arg: requestConfig.data,
        requestId: idGenerator(requestConfig.data),
        requestStatus: 'rejected'
      },
      payload: undefined,
      type: 'preCache',
      error
    });
  } finally {
    logger.debug(`Completed pre-cache for`, requestConfig);
    addAsyncFetchHistoryEntryFulfilled(preCacheHistory, id, {
      meta: {
        arg: requestConfig.data,
        requestId: idGenerator(requestConfig.data),
        requestStatus: 'fulfilled'
      },
      payload: undefined,
      type: 'preCache'
    });
  }
}

/**
 * Helper function to return a hook for pre-cache.
 *
 * @param props the props {@link CreateAsyncThunkQueryProps} used to configure and setup an async thunk query
 * @param preCacheHistory a record of pre-cache history
 * @returns a hook for pre-cache
 */
function createUsePreCacheHook<
  Args,
  Result,
  SliceState,
  CustomQueryParams extends [...unknown[]],
  State
>(
  props: Required<CreateAsyncThunkQueryProps<Args, Result, SliceState, CustomQueryParams, State>>,
  preCacheHistory: AsyncFetchHistory<Args> = {}
) {
  const { typePrefix, preCacheEnabled, logger, config } = props;
  const {
    idGenerator,
    shouldSkip,
    getSliceState,
    getHistory,
    transformArgs,
    prepareRequestConfig
  } = props;

  if (!preCacheEnabled) {
    return (): PreCache<Args> => {
      React.useEffect(() => {
        logger.debug(`Pre-cache is disabled for ${typePrefix}`);
      }, []);
      return React.useCallback(async () => Promise.resolve(undefined), []);
    };
  }

  return (): PreCache<Args> => {
    const store = useSelector((state: State) => state);
    const sliceState = useSelector((state: State) => getSliceState(state));
    const reduxHistory = getHistory(sliceState);
    return React.useCallback(
      async (
        args: Args,
        getPreCacheVisibility: (
          requestConfig: PriorityRequestConfig<Args>
        ) => number | undefined = () => undefined
      ) => {
        // merge the history; okay if the pre-cache history is overridden by the history
        const history: AsyncFetchHistory<Args> = { ...preCacheHistory, ...reduxHistory };

        const id = `preCache${idGenerator(args)}`;
        const data = transformArgs(args, history, id, flattenFilterHistory(history, id));

        if (!shouldSkip(data)) {
          const requestConfigs = prepareRequestConfig(
            data,
            config,
            history,
            id,
            flattenFilterHistory(history, id),
            store
          );

          if (requestConfigs.length > 0) {
            logger.debug(`Calling pre-cache for`, requestConfigs);
            await Promise.all(
              requestConfigs.map(async requestConfig => {
                await preCache(
                  id,
                  requestConfig,
                  preCacheHistory,
                  idGenerator,
                  getPreCacheVisibility,
                  logger
                );
              })
            ).catch(error => {
              logger.error(`Failed to pre-cache for`, requestConfigs, error);
              Object.keys(preCacheHistory[id]).forEach(key => {
                addAsyncFetchHistoryEntryRejected(preCacheHistory, id, {
                  meta: {
                    arg: preCacheHistory[id][key].arg,
                    requestId: key,
                    requestStatus: 'rejected'
                  },
                  payload: undefined,
                  type: 'preCache',
                  error
                });
              });
            });
          }
        }
      },
      [reduxHistory, store]
    );
  };
}

/**
 * Creates an async thunk query.
 *
 * @param props the props {@link CreateAsyncThunkQueryProps} used to configure and setup an async thunk query
 * @returns an async thunk query and a helper function for adding the reducers
 */
export function createAsyncThunkQuery<
  Args,
  Result,
  SliceState,
  CustomQueryParams extends [...unknown[]] = never,
  State = AppState
>(
  props: CreateAsyncThunkQueryProps<Args, Result, SliceState, CustomQueryParams, State>
): CreateAsyncThunkQuery<Args, Result, State, SliceState> {
  const { typePrefix, config } = props;
  const { idGenerator, getSliceState, getHistory } = props;
  const { shouldSkip, updateState } = props;

  // determine if pre-cache is enabled
  const preCacheEnabled = (props.preCacheEnabled ?? false) && !GMS_DISABLE_PRE_CACHE;

  const logger = props.logger || DEFAULT_LOGGER;

  const maxActiveAsyncRequests = props.maxActiveAsyncRequests || DEFAULT_MAX_ACTIVE_ASYNC_REQUESTS;

  const getWritableHistory: GetWritableHistory<Args, SliceState> = getHistory as GetWritableHistory<
    Args,
    SliceState
  >;

  const transformArgs: TransformArgs<Args> = (
    args: Args,
    history: AsyncFetchHistory<Args>,
    id: string = idGenerator(args),
    entries: AsyncFetchHistoryEntry<Args>[] = flattenFilterHistory(history, id)
  ) => {
    if (props.transformArgs) {
      return props.transformArgs(args, history, id, entries);
    }
    // return the arguments as is
    return args;
  };

  const prepareRequestConfig: PrepareRequestConfig<Args, State> = (
    args,
    requestConfig,
    history,
    id,
    entries,
    store
  ) => {
    const requestConfigs = props.prepareRequestConfig
      ? props.prepareRequestConfig(args, requestConfig, history, id, entries, store)
      : [defaultPrepareRequestConfig(args, requestConfig)];
    return (
      requestConfigs
        // transform the individual chunked requests (deduplication could change) and filter out
        .map(r => ({
          ...r,
          data: transformArgs(r.data, history, id, flattenFilterHistory(history, id))
        }))
        .filter(r => !shouldSkip(r.data))
    );
  };

  const customQueryParams = (state: State) =>
    props.customQueryParams ? props.customQueryParams(state) : ([] as unknown as CustomQueryParams);

  const customQueryFunc: QueryFunc<Args, CustomQueryParams, Result> =
    props.customQueryFunc ??
    (async (requestConfig, ...additionalParameters) => {
      if (requestConfig.baseURL == null) {
        logger.error(
          `Invalid request config, url is provided`,
          requestConfig,
          additionalParameters
        );
        throw new Error(`Invalid request config, url is provided`);
      }

      const axiosQueryFn = axiosBaseQuery<Result>({ baseUrl: requestConfig.baseURL });
      return (await axiosQueryFn({ requestConfig }, {} as BaseQueryApi, {} as ExtraOptions)).data;
    });

  const transformResult =
    props.transformResult ||
    ((args, results) => {
      if (!results || results.length === 0) {
        throw Error(`Invalid results received; expect at least one result`);
      }
      if (results.length > 1) {
        throw Error(`Must provide a custom transformResult implementation to combine results`);
      }
      return results[0];
    });

  const validateResult: ValidateResult<Args, Result, State> =
    props.validateResult || (() => undefined);

  // an internal queue of requests; used for throttling requests
  const queuedRequests: Record<string, number> = {};

  // an internal history of any pre-cached query requests
  const preCacheHistory: AsyncFetchHistory<Args> = {};

  // creates a async thunk for issuing a query.
  const asyncQuery = createAsyncQuery(
    {
      typePrefix,
      config,
      logger,
      maxActiveAsyncRequests,
      idGenerator,
      getSliceState,
      getHistory,
      shouldSkip,
      transformArgs,
      prepareRequestConfig,
      customQueryParams,
      customQueryFunc,
      transformResult,
      validateResult,
      updateState,
      preCacheEnabled
    },
    queuedRequests,
    preCacheHistory
  );

  // creates a function that can be used to inject the reducers to the provided builder.
  const addMatchReducers = (builder: ActionReducerMapBuilder<SliceState>): void => {
    builder
      .addMatcher(
        (action): action is ReturnType<typeof asyncQuery.pending> => {
          if (asyncQuery.pending.match(action)) {
            // if the request has been queued as a re-request; then do not update the state back to `pending`
            if (queuedRequests[action.meta.requestId] != null) {
              return false;
            }
            return true;
          }
          return false;
        },
        (state, action) => {
          const history = getWritableHistory(state);
          addAsyncFetchHistoryEntryPending(history, action.meta.requestId, action);
        }
      )

      .addMatcher(
        (action): action is ReturnType<typeof asyncQuery.fulfilled> =>
          asyncQuery.fulfilled.match(action),
        (state, action) => {
          const history = getWritableHistory(state);
          addAsyncFetchHistoryEntryFulfilled(history, action.meta.requestId, action);

          // add the query results to the Redux store slice
          updateState(action, state);

          // ensure the request is not longer marked as queued
          delete queuedRequests[action.meta.requestId];
        }
      )

      .addMatcher(
        (action): action is ReturnType<typeof asyncQuery.rejected> =>
          asyncQuery.rejected.match(action),
        (state, action) => {
          const history = getWritableHistory(state);
          addAsyncFetchHistoryEntryRejected(history, action.meta.requestId, action);

          // ensure the request is not longer marked as queued
          delete queuedRequests[action.meta.requestId];
        }
      );
  };

  const usePreCache = createUsePreCacheHook(
    {
      typePrefix,
      config,
      logger,
      maxActiveAsyncRequests,
      idGenerator,
      getSliceState,
      getHistory,
      shouldSkip,
      transformArgs,
      prepareRequestConfig,
      customQueryParams,
      customQueryFunc,
      transformResult,
      validateResult,
      updateState,
      preCacheEnabled
    },
    preCacheHistory
  );

  return { asyncQuery, addMatchReducers, usePreCache };
}
